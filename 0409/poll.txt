struct pollfd fds[4096];
// 감시하고자 하는 디스크립터를 하고 싶은 것만 감시하는 것이다.
// select 는 set 되어있는 것을 감시하는 것이다. 

fds[0].fd = ssock;
fds[0].events = POLLIN;
int nfds = 1;

int i;
int ret;
char buf[512];
while (1) {
	poll(fds, nfds, -1);
	for (i = 0; i < nfds; ++i) {
		if (fds[i].revents &POLLIN) {
			if (fds[i].fd == ssock) {
				if (csock == -1) {
					perror("accept");
					return 1;
				}
				//감시하고자 하는 디스크립터를 등록한다.
				fds[nfds].fd = csock;
				fds[nfds].events = POLLIN; //read의 이벤트를 감시를 하고 싶다.
				nfds++;
			} else {
				int fd = fds[i].fd;
				ret = read(fd, buf, sizeof buf);
				if (ret <= 0) {
					printf("연결이 종료되었습니다 \n");
					FD_CLR(fd, &fds);

				}
				write(fd, buf, ret);
			}
		}
		// poll의 핵심 : 감시하고자하는 디스크립터 배열을 직접 관리 해야한다.
		// 새로운 디스크립터를 추가하고 삭제하는 로직을 작성해야한다. 
		// 로직을 작성하면된다. 
		// -1이 아닌것만 복사해서 해당 값을 작성한다. 
		if (compress) {
			int n = 0;
			struct pollfd temp[4096];
			for (i = 0; i < nfds; ++i) {
				if (fds[i].fd != -1) {
					temp[n++] = fds[i];
				}
			}
			memcpy(fds, temp, n * sizeof(pollfd));
			nfds = n;
			compress = 0;
		}
	}
}

동작 중간에 배열의 값이 변경되는 것은 좋지 않다. 
로직에 flag를 만들어서 처리를 해준다. 

